"use strict";(self.webpackChunkapllodb_doc=self.webpackChunkapllodb_doc||[]).push([[373],{280:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return o},contentTitle:function(){return m},metadata:function(){return s},toc:function(){return p},default:function(){return u}});var n=a(7462),i=a(3366),l=(a(7294),a(3905)),r=["components"],o={sidebar_position:3,slug:"/ImmutableSchema/"},m="Immutable Schema",s={unversionedId:"immutable-schema",id:"immutable-schema",isDocsHomePage:!1,title:"Immutable Schema",description:"As described in Introduction, Immutable Schema consists of Immutable DDL and Immutable DML.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/03-immutable-schema.md",sourceDirName:".",slug:"/ImmutableSchema/",permalink:"/en/ImmutableSchema/",editUrl:"https://github.com/apllodb/apllodb.github.io/docs/03-immutable-schema.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,slug:"/ImmutableSchema/"},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/en/introduction/"},next:{title:"Future Development Plan",permalink:"/en/future-work/"}},p=[{value:"Immutable DDL Overview",id:"immutable-ddl-overview",children:[]},{value:"Details of Immutable DDL.",id:"details-of-immutable-ddl",children:[]},{value:"SELECT behavior",id:"select-behavior",children:[{value:"INSERT behavior",id:"insert-behavior",children:[]}]},{value:"Immutable DML Overview",id:"immutable-dml-overview",children:[]},{value:"Immutable DDL and Immutable DML implementations",id:"immutable-ddl-and-immutable-dml-implementations",children:[{value:"Full scan case",id:"full-scan-case",children:[]},{value:"Exact match search by primary key",id:"exact-match-search-by-primary-key",children:[]},{value:"Range search by primary key",id:"range-search-by-primary-key",children:[]},{value:"Exact match search and range search by non-primary key.",id:"exact-match-search-and-range-search-by-non-primary-key",children:[]}]}],d={toc:p};function u(e){var t=e.components,o=(0,i.Z)(e,r);return(0,l.kt)("wrapper",(0,n.Z)({},d,o,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"immutable-schema"},"Immutable Schema"),(0,l.kt)("p",null,"As described in ",(0,l.kt)("a",{parentName:"p",href:"/en/introduction/"},"Introduction"),", Immutable Schema consists of Immutable DDL and Immutable DML.\nImmutable Schema enables the organization of new information obtained through observation of data  for digital material management  without destroying existing data (records)."),(0,l.kt)("p",null,"This chapter describes the specifications of Immutable DDL and Immutable DML, and some implementation details in v0.1."),(0,l.kt)("h2",{id:"immutable-ddl-overview"},"Immutable DDL Overview"),(0,l.kt)("p",null,"In DDL of a normal RDBMS, table definitions created with the ",(0,l.kt)("inlineCode",{parentName:"p"},"CREATE TABLE")," statement can be modified with the ",(0,l.kt)("inlineCode",{parentName:"p"},"ALTER TABLE")," statement or dropped with the ",(0,l.kt)("inlineCode",{parentName:"p"},"DROP TABLE")," statement.\nIf a table definition is modified (dropped) with ",(0,l.kt)("inlineCode",{parentName:"p"},"ALTER TABLE")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"DROP TABLE"),", the original table definition cannot be recovered."),(0,l.kt)("p",null,"Immutable DDL makes this possible.\nIn Immutable DDL, a table has ",(0,l.kt)("strong",{parentName:"p"},"versions"),"."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"CREATE TABLE t ... ")," creates ",(0,l.kt)("inlineCode",{parentName:"li"},"v1")," of table ",(0,l.kt)("inlineCode",{parentName:"li"},"t"),"."),(0,l.kt)("li",{parentName:"ul"},"Then ",(0,l.kt)("inlineCode",{parentName:"li"},"ALTER TABLE t ... ")," creates ",(0,l.kt)("inlineCode",{parentName:"li"},"v2")," of table ",(0,l.kt)("inlineCode",{parentName:"li"},"t"),". The table definition of ",(0,l.kt)("inlineCode",{parentName:"li"},"v1")," and the records inside ",(0,l.kt)("inlineCode",{parentName:"li"},"v1")," will remain unchanged."),(0,l.kt)("li",{parentName:"ul"},"Then ",(0,l.kt)("inlineCode",{parentName:"li"},"DROP TABLE t")," will create ",(0,l.kt)("inlineCode",{parentName:"li"},"v3")," of table ",(0,l.kt)("inlineCode",{parentName:"li"},"t")," as in deactivated state. Since ",(0,l.kt)("inlineCode",{parentName:"li"},"v3")," is in deactivated state, any operation on ",(0,l.kt)("inlineCode",{parentName:"li"},"t")," will fail basically. The records associated with ",(0,l.kt)("inlineCode",{parentName:"li"},"v1")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"v2")," remain intact.")),(0,l.kt)("p",null,"The behavior in the case of ",(0,l.kt)("inlineCode",{parentName:"p"},"ALTER TABLE")," is illustrated below."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"`ALTER TABLE ... ADD`",src:a(3594).Z})),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Quoted from ",(0,l.kt)("a",{parentName:"em",href:"https://docs.google.com/presentation/d/e/2PACX-1vTxGlW6UwmR-fHAIki1IPb7zFy7mQ0WRBFywsN_3S5jm6CdekF9qhxT3DYezBzHtx5S1bX5XiHeOACk/pub?start=false&loop=false&delayms=3000"},'"Introduction to apllodb" slides')),"."),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"ADD COLUMN")," adding a ",(0,l.kt)("inlineCode",{parentName:"p"},"NOT NULL")," column without any default value is not possible in a normal RDBMS because it doesn't know what value to set to the new column of an existing record.\nWith Immutable DDL, ",(0,l.kt)("inlineCode",{parentName:"p"},"v2")," is created without error. Table definition before adding the column remains as ",(0,l.kt)("inlineCode",{parentName:"p"},"v1")," and records are kept in ",(0,l.kt)("inlineCode",{parentName:"p"},"v1"),".\nNext INSERT will be directed to ",(0,l.kt)("inlineCode",{parentName:"p"},"v2")," if the value is also set for the added column."),(0,l.kt)("p",null,"Next, let's look at an example of ",(0,l.kt)("inlineCode",{parentName:"p"},"DROP COLUMN"),"."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"`ALTER TABLE ... DROP`",src:a(8173).Z})),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Quoted from ",(0,l.kt)("a",{parentName:"em",href:"https://docs.google.com/presentation/d/e/2PACX-1vTxGlW6UwmR-fHAIki1IPb7zFy7mQ0WRBFywsN_3S5jm6CdekF9qhxT3DYezBzHtx5S1bX5XiHeOACk/pub?start=false&loop=false&delayms=3000"},'"Introduction to apllodb" slides')),"."),(0,l.kt)("p",null,"In a normal RDBMS, column values will also disappear from existing records. There is nothing wrong with this behavior, but in the case of digital document management, there may be a case where you don't want to fill this column anymore, but want to keep the column values you have filled so far.\nIn this case, Immutable DDL can be useful. Even if you delete a column from a table definition, the table definition and records before the column deletion will remain in ",(0,l.kt)("inlineCode",{parentName:"p"},"v1"),"."),(0,l.kt)("p",null,"So far, we have explained that issuing DDL creates a new version in the table definition, and the records are still associated with old versions.\nIn the next section, we will explain how DML such as ",(0,l.kt)("inlineCode",{parentName:"p"},"SELECT")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"INSERT")," behaves in a situation where multiple versions exist."),(0,l.kt)("h2",{id:"details-of-immutable-ddl"},"Details of Immutable DDL."),(0,l.kt)("h2",{id:"select-behavior"},"SELECT behavior"),(0,l.kt)("p",null,"When the ",(0,l.kt)("inlineCode",{parentName:"p"},"SELECT")," target table is ",(0,l.kt)("inlineCode",{parentName:"p"},"t"),", all versions (not deactivated via ",(0,l.kt)("inlineCode",{parentName:"p"},"DROP TABLE"),") will be processed according to the following rules."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"(Rule 1)")," Error if the column ",(0,l.kt)("inlineCode",{parentName:"li"},"c")," in the ",(0,l.kt)("inlineCode",{parentName:"li"},"SELECT")," statement does not exist in any version of ",(0,l.kt)("inlineCode",{parentName:"li"},"t"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"(Rule 2)")," If ",(0,l.kt)("inlineCode",{parentName:"li"},"c")," exists in some version of ",(0,l.kt)("inlineCode",{parentName:"li"},"t"),", records in that version return the column value for ",(0,l.kt)("inlineCode",{parentName:"li"},"c"),"."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"(Rule 3)")," If ",(0,l.kt)("inlineCode",{parentName:"li"},"c")," column does not exist in some version, records of that version return NULL value for ",(0,l.kt)("inlineCode",{parentName:"li"},"c"),".")),(0,l.kt)("p",null,"Let's explain with an example.\nConsider the following three versions and records are in table ",(0,l.kt)("inlineCode",{parentName:"p"},"t"),"."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-text"},"v3\n| c1 | c2 |\n|----|----|\n| 1  | 10 |\n\nv2\n| c1 | c2 | c3 |\n|----|----|----|\n| 3  | 30 | 33 |\n\nv1\n| c1 |\n|----|\n| 2  |\n")),(0,l.kt)("p",null,"At this time, the"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT c4 FROM t;\n")),(0,l.kt)("p",null,"will result in an error according to rule 1 (the column c4 does not exist)."),(0,l.kt)("p",null,"Let's look at some other examples."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT c1 FROM t;\n\n-- result (in undefined order)\n| c1 |\n|----|\n| 1  |\n| 3  |\n| 2  |\n")),(0,l.kt)("p",null,"Rule 2 is applied."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT c1, c2, c3 FROM t;\n\n-- result (undefined order)\n| c1 | c2   | c3   |\n|----|------|------|\n| 1  | 10 | NULL |\n| 3  | 30 | 33   |\n| 2  | NULL | NULL |\n")),(0,l.kt)("p",null,"Rules 2 and 3 are applied."),(0,l.kt)("p",null,"So far, we've learned Projection (specifying the columns to fetch immediately after the ",(0,l.kt)("inlineCode",{parentName:"p"},"SELECT"),"), let's look at"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"WHERE")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"GROUP BY")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"ORDER BY")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"JOIN"))),(0,l.kt)("p",null,"The same rules apply to the columns that appear in the above clauses.\nBy rule 3, NULL may appear but these operations have defined behavior as SQL standard when NULL appears",(0,l.kt)("sup",{parentName:"p",id:"fnref-1"},(0,l.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1")),", and return the result according to that specifications."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT c1, c2, c3 FROM t WHERE c2 > 15;\n\n-- result\n| c1 | c2 | c3 |\n|----|------|------|\n| 3 | 30 | 33 |\n")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT c1, c2, c3 FROM t ORDER BY c2 DESC;\n\n-- result (NULL is subordinate to any value)\n| c1 | c2 | c3 |\n|----|------|------|\n| 3  | 30   | 33   |\n| 1  | 10   | NULL |\n| 2  | NULL | NULL |\n")),(0,l.kt)("p",null,(0,l.kt)("sup",{parentName:"p",id:"fnref-1"},(0,l.kt)("a",{parentName:"sup",href:"#fn-1",className:"footnote-ref"},"1"))," ",(0,l.kt)("inlineCode",{parentName:"p"},"GROUP BY nullable_column"),", for example, have different default behavior depending on RDBMS implementations. apllodb v0.1 adopts PostgreSQL compliant semantics."),(0,l.kt)("h3",{id:"insert-behavior"},"INSERT behavior"),(0,l.kt)("p",null,"When the table to be ",(0,l.kt)("inlineCode",{parentName:"p"},"INSERT"),"ed is ",(0,l.kt)("inlineCode",{parentName:"p"},"t"),", all versions (not deactivated by ",(0,l.kt)("inlineCode",{parentName:"p"},"DROP TABLE"),") will be processed according to the following rules."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"(Rule 1)")," Iterate versions in descending order, and attempt to insert a record into a version if an insert with an ",(0,l.kt)("inlineCode",{parentName:"li"},"INSERT")," statement can be performed successfully for that version.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"(Rule 1.1)")," Error if a table-wide constraint is violated."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"(Rule 1.2)")," Otherwise, insert into that version completes successfully."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"(Rule 2)")," If rule 1 does not work for one version, choose a smaller version and repeat."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("strong",{parentName:"li"},"(Rule 3)")," If the insertion into ",(0,l.kt)("inlineCode",{parentName:"li"},"v1")," does not complete successfully, the execution of the ",(0,l.kt)("inlineCode",{parentName:"li"},"INSERT")," statement will fail.")),(0,l.kt)("p",null,"Let's explain with an example.\nConsider the case where the table ",(0,l.kt)("inlineCode",{parentName:"p"},"t")," has the following three versions and a table-wide constraint"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"v3",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"c1"),": NOT NULL"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"c2"),": NOT NULL"))),(0,l.kt)("li",{parentName:"ul"},"v2",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"c1"),": NOT NULL"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"c2"),": NOT NULL"),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"c3"),": NULL"))),(0,l.kt)("li",{parentName:"ul"},"v1",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"c1"),": NOT NULL"))),(0,l.kt)("li",{parentName:"ul"},"Table-wide constraints",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"id"),": PRIMARY KEY")))),(0,l.kt)("p",null,"Let's look at a few ",(0,l.kt)("inlineCode",{parentName:"p"},"INSERT")," statements and their results."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO t (c1, c2) VALUES (1, 10);\n")),(0,l.kt)("p",null,"Following rule 1, apllodb will first try to insert into ",(0,l.kt)("inlineCode",{parentName:"p"},"v3"),". Insertion into ",(0,l.kt)("inlineCode",{parentName:"p"},"v3")," is OK, so rule 1.2 will complete the INSERT statement successfully.\n(Inserting into ",(0,l.kt)("inlineCode",{parentName:"p"},"v2")," is also possible, but ",(0,l.kt)("inlineCode",{parentName:"p"},"v2")," will not be selected, since the INSERT candidates are ordered by descending version."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO t (c1, c2, c3) VALUES (3, 30, 33);\n")),(0,l.kt)("p",null,"Following rule 1, apllodb first try to insert into ",(0,l.kt)("inlineCode",{parentName:"p"},"v3"),". Since ",(0,l.kt)("inlineCode",{parentName:"p"},"v3")," does not have a column named ",(0,l.kt)("inlineCode",{parentName:"p"},"c3"),", apllodb move to rule 2, and then back to rule 1 with an attempt on ",(0,l.kt)("inlineCode",{parentName:"p"},"v2"),".\nInserting into ",(0,l.kt)("inlineCode",{parentName:"p"},"v2")," is OK, so rule 1.2 will complete the INSERT statement successfully."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO t (c1) VALUES (2);\n")),(0,l.kt)("p",null,"Both ",(0,l.kt)("inlineCode",{parentName:"p"},"v3")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"v2")," will fail because they require ",(0,l.kt)("inlineCode",{parentName:"p"},"c2"),".  ",(0,l.kt)("inlineCode",{parentName:"p"},"v1")," completes successfully."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO t (c4) VALUES (4);\n")),(0,l.kt)("p",null,"Since none of ",(0,l.kt)("inlineCode",{parentName:"p"},"v3"),", ",(0,l.kt)("inlineCode",{parentName:"p"},"v2"),", or ",(0,l.kt)("inlineCode",{parentName:"p"},"v1")," has ",(0,l.kt)("inlineCode",{parentName:"p"},"c4"),", rule 3 causes this INSERT statement to fail."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-sql"},"INSERT INTO t (c1, c2, c3) VALUES (1, 100, 111);\n")),(0,l.kt)("p",null,(0,l.kt)("inlineCode",{parentName:"p"},"v3")," does not have ",(0,l.kt)("inlineCode",{parentName:"p"},"c3"),", so it tries to insert into ",(0,l.kt)("inlineCode",{parentName:"p"},"v2"),".\nSince the record with ",(0,l.kt)("inlineCode",{parentName:"p"},"c1 = 1")," already exists, it violates the table-wide constraint ",(0,l.kt)("inlineCode",{parentName:"p"},"c1 PRIMARY KEY"),". Therefore, according to rule 1.1, this INSERT statement will result in an error."),(0,l.kt)("h2",{id:"immutable-dml-overview"},"Immutable DML Overview"),(0,l.kt)("p",null,"In a normal RDBMS DML, a record created with an ",(0,l.kt)("inlineCode",{parentName:"p"},"INSERT")," statement can be updated with an ",(0,l.kt)("inlineCode",{parentName:"p"},"UPDATE")," statement or deleted with a ",(0,l.kt)("inlineCode",{parentName:"p"},"DELETE")," statement.\nIf a record is updated (deleted) by ",(0,l.kt)("inlineCode",{parentName:"p"},"UPDATE")," or ",(0,l.kt)("inlineCode",{parentName:"p"},"DELETE"),", the original record cannot be recovered ",(0,l.kt)("sup",{parentName:"p",id:"fnref-2"},(0,l.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2")),"."),(0,l.kt)("p",null,"Immutable DML allows records to have ",(0,l.kt)("strong",{parentName:"p"},"revision")," and to be restored to a previous revision."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"A table always has a primary key, and the primary key is the same for all versions."),(0,l.kt)("li",{parentName:"ul"},"There is a one-to-many association between primary keys and revisions."),(0,l.kt)("li",{parentName:"ul"},"The first time the value of a primary key is created by an ",(0,l.kt)("inlineCode",{parentName:"li"},"INSERT")," statement, the record will be in the ",(0,l.kt)("inlineCode",{parentName:"li"},"r1")," revision."),(0,l.kt)("li",{parentName:"ul"},"When the record of the primary key is updated by an ",(0,l.kt)("inlineCode",{parentName:"li"},"UPDATE")," statement, the record of ",(0,l.kt)("inlineCode",{parentName:"li"},"r1")," remains unchanged, and the record of ",(0,l.kt)("inlineCode",{parentName:"li"},"r2")," is created (internally, the ",(0,l.kt)("inlineCode",{parentName:"li"},"INSERT")," process runs)."),(0,l.kt)("li",{parentName:"ul"},"When a record with the same primary key is deleted by a ",(0,l.kt)("inlineCode",{parentName:"li"},"DELETE")," statement, the record of ",(0,l.kt)("inlineCode",{parentName:"li"},"r3")," is created with only a delete mark and no content."),(0,l.kt)("li",{parentName:"ul"},"In ",(0,l.kt)("inlineCode",{parentName:"li"},"SELECT"),", only the latest revision of the same primary key is retrieved. If the latest revision has a delete mark, the record of the primary key will not be retrieved.")),(0,l.kt)("p",null,"Here is an illustration of the behavior in the case of ",(0,l.kt)("inlineCode",{parentName:"p"},"UPDATE"),"."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"`UPDATE`",src:a(6602).Z})),(0,l.kt)("p",null,(0,l.kt)("em",{parentName:"p"},"Quoted from ",(0,l.kt)("a",{parentName:"em",href:"https://docs.google.com/presentation/d/e/2PACX-1vTxGlW6UwmR-fHAIki1IPb7zFy7mQ0WRBFywsN_3S5jm6CdekF9qhxT3DYezBzHtx5S1bX5XiHeOACk/pub?start=false&loop=false&delayms=3000"},'"Introduction to apllodb" slide')),"."),(0,l.kt)("p",null,"In a normal RDBMS, the value of ",(0,l.kt)("inlineCode",{parentName:"p"},"c1")," is overwritten by ",(0,l.kt)("inlineCode",{parentName:"p"},"UPDATE")," and cannot usually be restored to its original value ",(0,l.kt)("sup",{parentName:"p",id:"fnref-3"},(0,l.kt)("a",{parentName:"sup",href:"#fn-3",className:"footnote-ref"},"3")),".\nIn digital document management, we believe that we often want to revert records they were before modified or deleted.\nIn Immutable DML, past records remain in the form of revisions, which can be recovered if necessary. It is also possible to extract the change history of a record."),(0,l.kt)("p",null,(0,l.kt)("sup",{parentName:"p",id:"fnref-2"},(0,l.kt)("a",{parentName:"sup",href:"#fn-2",className:"footnote-ref"},"2"))," Some RDBMSs have destructive DMLs like UPDATE and DELETE in append-manner like Immutable DML. Many of them perform garbage collection at some point (background processing, ",(0,l.kt)("inlineCode",{parentName:"p"},"VACUUM")," command, etc.) to complete destructive DML. The aim is to reduce capacity and improve performance."),(0,l.kt)("p",null,(0,l.kt)("sup",{parentName:"p",id:"fnref-3"},(0,l.kt)("a",{parentName:"sup",href:"#fn-3",className:"footnote-ref"},"3"))," Possible if you have snapshot backups but we don't think many systems support record-by-record recovery."),(0,l.kt)("h2",{id:"immutable-ddl-and-immutable-dml-implementations"},"Immutable DDL and Immutable DML implementations"),(0,l.kt)("p",null,"apllodb v0.1 uses SQLite for table structure and record storage (and transaction).\nImmutable DDL and Immutable DML are also implemented over SQLite."),(0,l.kt)("p",null,"In this section, we will explain how to realize Immutable Schema based on existing RDBMS."),(0,l.kt)("p",null,(0,l.kt)("img",{alt:"ER diagram for Immutable Schema realization",src:a(9029).Z})),(0,l.kt)("p",null,"We will set up tables as shown in the above figure in the existing RDBMS.\nThe layer with blue background is the real tables that need to be created for one table ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," in Immutable Schema.\nThe figure above shows a setup where table ",(0,l.kt)("inlineCode",{parentName:"p"},"T")," has two versions, ",(0,l.kt)("inlineCode",{parentName:"p"},"v1")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"v2"),"."),(0,l.kt)("p",null,"The role of each table is as follows"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Physical tables for all apllodb's tables",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"_vtable_metadata"),".",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Manages the metadata for the table.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Currently, constraints table-wide constraints (PRIMARY KEY, UNIQUE) for metadata."))))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"_version_metadata"),".",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Manage metadata for each version.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Version number"),(0,l.kt)("li",{parentName:"ul"},"Name and data type of each column."),(0,l.kt)("li",{parentName:"ul"},"Constraints to check one record at a time (NOT NULL, DEFAULT, CHECK, ...)"),(0,l.kt)("li",{parentName:"ul"},"Active version (not being ",(0,l.kt)("inlineCode",{parentName:"li"},"DROP TABLE"),"ed)"))))))),(0,l.kt)("li",{parentName:"ul"},"Real table for table `T",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"T__navi"),".",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"A relay table for locating the entity of a record with a primary key.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"Also supports composite primary keys."))),(0,l.kt)("li",{parentName:"ul"},'It has a revision number, and "the latest revision with a primary key value" is found in this table.'),(0,l.kt)("li",{parentName:"ul"},"It has a version number and can be used to join non-primary key column values with the ",(0,l.kt)("inlineCode",{parentName:"li"},"T__v?")," table."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"T__v?"),".",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"holds the records (non-primary key columns) of version ",(0,l.kt)("inlineCode",{parentName:"li"},"v?"),".")))))),(0,l.kt)("p",null,"See ",(0,l.kt)("a",{parentName:"p",href:"https://github.com/apllodb/apllodb/tree/main/apllodb-immutable-schema-engine#sqlite-schema-design"},"README of the storage engine")," for details of columns in the real table."),(0,l.kt)("p",null,"Here is an overview of how these tables are referenced in a ",(0,l.kt)("inlineCode",{parentName:"p"},"SELECT")," statement."),(0,l.kt)("h3",{id:"full-scan-case"},"Full scan case"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Browse the ",(0,l.kt)("inlineCode",{parentName:"li"},"T__navi")," table and extract the record with the highest revision number for each primary key value."),(0,l.kt)("li",{parentName:"ol"},"Get the non-primary key column values of those records by joining them with the ",(0,l.kt)("inlineCode",{parentName:"li"},"T__v?")," table.")),(0,l.kt)("h3",{id:"exact-match-search-by-primary-key"},"Exact match search by primary key"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Refer to the ",(0,l.kt)("inlineCode",{parentName:"li"},"T__navi")," table, do a match search for the primary key value, and extract the record with the highest revision number."),(0,l.kt)("li",{parentName:"ol"},"Get the non-primary key column value of the record by joining it with the ",(0,l.kt)("inlineCode",{parentName:"li"},"T__v?")," table.")),(0,l.kt)("h3",{id:"range-search-by-primary-key"},"Range search by primary key"),(0,l.kt)("ol",null,(0,l.kt)("li",{parentName:"ol"},"Refer to the ",(0,l.kt)("inlineCode",{parentName:"li"},"T__navi")," table, do a range search for the primary key value, and extract the record with the highest revision number."),(0,l.kt)("li",{parentName:"ol"},"Get the non-primary key column value of the record by joining it with the ",(0,l.kt)("inlineCode",{parentName:"li"},"T__v?")," table.")),(0,l.kt)("h3",{id:"exact-match-search-and-range-search-by-non-primary-key"},"Exact match search and range search by non-primary key."),(0,l.kt)("p",null,"Indexes on non-primary keys are not supported in apllodb v0.1. Current apllodb performs performs full scan and then filter-out record that do not match the search criteria."),(0,l.kt)("p",null,'When we support indexing, we envision that the primary key can be subtracted from the index and from there it can be dropped into the "For match search by primary key".'))}u.isMDXComponent=!0},9029:function(e,t,a){t.Z=a.p+"assets/images/apllodb-0.1.0-SQLite-ER-diagram-a308ac17fd78cf8a5a46691610788b6b.svg"},3594:function(e,t,a){t.Z=a.p+"assets/images/immutable-ddl-alter-table-add.en-11a4e12a58cf4955cb19a52fdd1e7f04.png"},8173:function(e,t,a){t.Z=a.p+"assets/images/immutable-ddl-alter-table-drop.en-8f7d77014f38099cbd0bfc937d979f8d.png"},6602:function(e,t,a){t.Z=a.p+"assets/images/immutable-dml-update.en-aaacbc62a22e36f5711093764ac10140.png"}}]);